load unification.maude

fmod NARROWING-STEP-SET is
   protecting RESULT-CONTEXT-SET .

    sorts StepResult StepResult? .
    ------------------------------
    subsort StepResult < StepResult? .

    op failure   : -> StepResult? [ctor] .
    op {_,_,_/_} : Term Type Substitution RuleSet -> StepResult [ctor] .
    --------------------------------------------------------------------

    sort StepResultSet .
    --------------------
    subsort StepResult < StepResultSet .

    var M : Module . vars NextVar : Nat . vars S S' : Substitution .
    vars T TS CtTS : Term . var TL : TermList . var TP : Type . var R : Rule .
    var Tr : TraceNarrow . var B : Flags . vars Ct CtS : Context .
    var SR : StepResult . var RTS : ResultContextSet . var SRS : StepResultSet .

    op empty :                             -> StepResultSet [ctor] .
    op _||_  : StepResultSet StepResultSet -> StepResultSet [ctor assoc comm id: empty prec 65] .
    ---------------------------------------------------------------------------------------------
    eq SR || SR = SR .

    op to4Tuple : Module ResultContextSet -> StepResult .
    -----------------------------------------------------
    eq to4Tuple(M, empty ) = empty .
    eq to4Tuple(M, {T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr,B} | RTS )
     = {CtTS, leastSort(M,CtTS), S .. S' / getRuleSet(Tr)} || to4Tuple(M, RTS) .

    op _|>_ : StepResult TermList -> StepResult .
    ---------------------------------------------
    eq (empty).StepResult    |> TL = (empty).StepResult .
    eq ({T,TP,S / R} || SRS) |> TL = {T,TP,S |> TL / R} || (SRS |> TL) .
    eq (failure      || SRS) |> TL = failure || (SRS |> TL) .

    op getRuleSet : TraceNarrow -> RuleSet .
    ----------------------------------------
    eq getRuleSet(nil)           = none .
    eq getRuleSet({T,S,TP,R} Tr) = R getRuleSet(Tr) .

    sort VariantSet .
    -----------------
    subsort Variant < VariantSet .

    op emptyVariantSet :                       -> VariantSet [ctor] .
    op _#_             : VariantSet VariantSet -> VariantSet [ctor assoc comm id: emptyVariantSet prec 65 format (d d n d)] .
    -------------------------------------------------------------------------------------------------------------------------
    eq X:Variant # X:Variant = X:Variant .
endfm

eof

fmod FVP-NARROWING-GRAPH is
    protecting SUBSTITUTIONSET .

    var N : Nat . vars Q RL : Qid .
    vars S S' : State . var TYPE : Type . var CTX : Context .
    var M : Module . var T : Term . vars SUBST TSUBST RLSUBST : Substitution .

    op allNarrowSteps : Module Term Nat -> [TransitionSet] .
    --------------------------------------------------------
    eq allNarrowSteps(M, S, N) = .TransitionSet [owise] .
   ceq allNarrowSteps(M, S, N) = < TSUBST , S' > , allNarrowSteps(M, S, N + 1)
    if { T , TYPE , CTX , RL , TSUBST , RLSUBST , Q }
          := metaNarrowingApply(M, upTerm(S), empty, '#, N)
    /\ S' := downTerm(T, downStateError) .

    op step : Module State -> [TransitionSet] .
    -------------------------------------------
    eq step(M, S) = allNarrowSteps(M, S, 0) .

    --- One single match is enough to fold here.
    op fold : Module State State -> [Fold] .
    ----------------------------------------
   ceq fold(M, S, S') = SUBST if SUBST := metaMatch(M, upTerm(S'), upTerm(S), nil, 0) .
endfm

fmod FVP-NARROWING-MODULO-T-GRAPH is
    protecting SUBSTITUTIONSET .
    protecting NARROWING-GRAPH .
    protecting INTEGER .

    sorts Constraint CState .
    subsort State < CState .
    ------------------------
    vars NeTS NeTS' : NeTransitionSet . var T : Term . var N : Nat .
    vars C C' : Constraint . var M : Module . vars S S' : State .
    var SUBST : Substitution . var SUBSTS : SubstitutionSet .

    op downConstraintError : -> [Constraint] .
    op _<<_ : Constraint Substitution -> Constraint .
    -------------------------------------------------
   ceq C << SUBST = C'
    if T  := upTerm(C) << SUBST
    /\ C' := downTerm(T, downConstraintError) .

    op unsatis? : Constraint            -> [Bool] .
    op entails? : Constraint Constraint -> [Bool] .
    -----------------------------------------------

    op _|_ : State Constraint -> CState .
    op <_,_> : Step CState -> Transition .
    --------------------------------------

    op step : Module CState -> [TransitionSet] .
    --------------------------------------------
    eq step(M, S | C) = updateTransitions(C, step(M, S)) .

    op updateTransitions : Constraint TransitionSet -> [TransitionSet] .
    --------------------------------------------------------------------
    eq updateTransitions(C, .TransitionSet) = .TransitionSet .
    eq updateTransitions(C, (NeTS , NeTS')) = updateTransitions(C, NeTS) , updateTransitions(C, NeTS') .

   ceq updateTransitions(C, < SUBST , S >) = .TransitionSet             if C' := C << SUBST /\ unsatis?(C') .
    eq updateTransitions(C, < SUBST , S >) = < SUBST , S | C << SUBST > [owise] .

    op allMatches : Module State State Nat -> [SubstitutionSet] .
    -------------------------------------------------------------
    eq allMatches(M, S, S', N) = none [owise] .
   ceq allMatches(M, S, S', N) = SUBST | allMatches(M, S, S', N + 1)
    if SUBST := metaMatch(M, upTerm(S'), upTerm(S), nil, N) .

    op fold : Module CState CState -> [Fold] .
    ------------------------------------------
   ceq fold(M, S | C, S' | C') = SUBST
    if SUBST | SUBSTS := allMatches(M, S, S', 0)
    /\ entails?(C', C << SUBST) .
endfm
