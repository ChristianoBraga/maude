load ../lmc/lgraph-search.maude

fmod FVP-NARROWING-GRAPH is
    protecting META-LEVEL .
    extending GRAPH-FOLDING-SEARCH .

    subsort Substitution < Fold .
    -----------------------------
    var N : Nat .

    --- Need some sort of constant identification here.
    --- Perhaps this is telling us that we need a fth for the LGRAPH search stuff.
    eq N [ none ] = N [ .Fold ] .

    vars S S' : State . var TYPE : Type . var CTX : Context . vars Q RL : Qid .
    var M : Module . var T : Term . vars SUBST TSUBST RLSUBST : Substitution .

    op downStateError : -> [State] .
    --------------------------------

    subsort Substitution < Label .
    --- op _:_ : Qid Substitution -> Label .
    ----------------------------------------

    op allNarrowSteps : Module State Nat -> [TransitionSet] .
    ---------------------------------------------------------
    eq allNarrowSteps(M, S, N) = .TransitionSet [owise] .
   ceq allNarrowSteps(M, S, N) = < TSUBST , S' > , allNarrowSteps(M, S, N + 1)
    if { T , TYPE , CTX , RL , TSUBST , RLSUBST , Q }
          := metaNarrowingApply(M, upTerm(S), empty, '#, N)
    /\ S' := downTerm(T, downStateError) .

    op step : Module State -> [TransitionSet] .
    -------------------------------------------
    eq step(M, S) = allNarrowSteps(M, S, 0) .

    --- One single match is enough to fold here.
    op fold : Module State State -> [Fold] .
    ----------------------------------------
   ceq fold(M, S, S') = SUBST if SUBST := metaMatch(M, upTerm(S'), upTerm(S), nil, 0) .
endfm

eof

fmod FVP-NARROWING-MODULO-T-GRAPH is
    protecting SUBSTITUTIONSET .
    protecting NARROWING-GRAPH .
    protecting INTEGER .

    sorts Constraint CState .
    subsort State < CState .
    ------------------------
    vars NeTS NeTS' : NeTransitionSet . var T : Term . var N : Nat .
    vars C C' : Constraint . var M : Module . vars S S' : State .
    var SUBST : Substitution . var SUBSTS : SubstitutionSet .

    op downConstraintError : -> [Constraint] .
    op _<<_ : Constraint Substitution -> Constraint .
    -------------------------------------------------
   ceq C << SUBST = C'
    if T  := upTerm(C) << SUBST
    /\ C' := downTerm(T, downConstraintError) .

    op unsatis? : Constraint            -> [Bool] .
    op entails? : Constraint Constraint -> [Bool] .
    -----------------------------------------------

    op _|_ : State Constraint -> CState .
    op <_,_> : Step CState -> Transition .
    --------------------------------------

    op step : Module CState -> [TransitionSet] .
    --------------------------------------------
    eq step(M, S | C) = updateTransitions(C, step(M, S)) .

    op updateTransitions : Constraint TransitionSet -> [TransitionSet] .
    --------------------------------------------------------------------
    eq updateTransitions(C, .TransitionSet) = .TransitionSet .
    eq updateTransitions(C, (NeTS , NeTS')) = updateTransitions(C, NeTS) , updateTransitions(C, NeTS') .

   ceq updateTransitions(C, < SUBST , S >) = .TransitionSet             if C' := C << SUBST /\ unsatis?(C') .
    eq updateTransitions(C, < SUBST , S >) = < SUBST , S | C << SUBST > [owise] .

    op allMatches : Module State State Nat -> [SubstitutionSet] .
    -------------------------------------------------------------
    eq allMatches(M, S, S', N) = none [owise] .
   ceq allMatches(M, S, S', N) = SUBST | allMatches(M, S, S', N + 1)
    if SUBST := metaMatch(M, upTerm(S'), upTerm(S), nil, N) .

    op fold : Module CState CState -> [Fold] .
    ------------------------------------------
   ceq fold(M, S | C, S' | C') = SUBST
    if SUBST | SUBSTS := allMatches(M, S, S', 0)
    /\ entails?(C', C << SUBST) .
endfm
