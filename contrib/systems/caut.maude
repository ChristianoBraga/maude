--- ; Cellular Automata in Maude
--- ; ==========================

--- ; A cellular automata is a soup of cells, where each cell is holding some internal state.
--- ; Once a cell is “activated”, it reads the state of each of its neighbor cells to compute its own next state.
--- ; Once the next state has been computed, a cell waits to be deactivated.
--- ; All of the cells are activated simultaneously, and once all of the cells have computed their next state they are all deactivated.

--- ; Cellular Cultures
--- ; -----------------

--- ; We define the structure of a `Culture`. Every `Cell` is a singleton `Culture`.


mod CELLULAR-AUTOMATA is

    sorts State States State? .
    ---------------------------
    subsort State < States State? .

    sorts StateLabel StateKey .
    ---------------------------

    sorts Cell Culture .
    --------------------
    subsort Cell < Culture .


--- ; ### Cell

--- ; `Cell`s store a different amount of data, depending on whether they are “activated” or not.
--- ; They always store their own `StateLabel` and their own `State?`.
--- ; A `State?` can just be a regular `State` (by subsorting), or it can be a `State` and a `States` (using the `_->_` operator), meaning the `Cell` is activated and calculating its next state.


    op _->_ : State States -> State? [prec 56] .
    op _::_ : StateLabel State? -> Cell [prec 57] .
    -----------------------------------------------


--- ; ### Culture

--- ; We have an “empty” `Culture` (`mt`), and say that `Culture`s can be combined associatively/comuttatively using the `_;_` operator.


    op mt  : -> Culture [ctor] .
    op _;_ : Culture Culture -> Culture [assoc comm idem id: mt prec 60 format(d n d d)] .
    --------------------------------------------------------------------------------------


--- ; ### Computing Next State

--- ; When computing the next state for the current cell, we’ll need a list of neigbhoring states.
--- ; To know which neighboring cell corresponds to each neighboring state, we’ll use a marker `StateKey`, which can hold either the `StateLabel` or the `State` of the state it corresponds to.


    vars N N'   : StateLabel .
    vars S S'   : State .
    var  SS SS' : States .
    var  SK     : StateKey .

    op mt   : -> States .
    op __   : States   States     -> States [assoc comm id: mt prec 55] .
    op _[_] : StateKey State      -> States .
    op _[_] : StateKey StateLabel -> States .
    -----------------------------------------
    eq   N :: S -> SK[N] SS
       = N :: S -> SK[S] SS .

    eq   N :: S -> SK[N'] SS ; N' :: S' -> SS'
       = N :: S -> SK[S'] SS ; N' :: S' -> SS' .


--- ; ### Neighbor Lookup

--- ; If what we’re holding is the `StateLabel`, we need to do a lookup in the associative commutative soup of `Cell` to find the corresponding `State`.
--- ; It could be that the `StateLabel` refers to our own state, which needs to be handled specially.

--- ; The `neighbors` function is used to calculate which neighbors are relevant to each `Cell`.
--- ; This is simulation specific.


    op neighbors : StateLabel -> State? .
    -------------------------------------


--- ; ### Life Cycle

--- ; To drive the whole simulation forward, we’ll need a `Clock` which switches back and forth between two states, `tick` and `tock`.
--- ; A `Clock` together with a `Culture` is a `Dish`.


    sort Dish .
    -----------

    var C : Culture .

    op [_] : Culture -> Dish .
    --------------------------
    eq [ N :: S                 ; C ]
     = [ N :: S -> neighbors(N) ; C ] .

    op {_} : Culture -> Dish .
    --------------------------
    eq { N :: S -> S' ; C }
     = { N :: S'      ; C } .


--- ; Notice that when the square brackets (`[_]`) surround a `Culture`, any unactivated `Cell` is activated by querying the `neighbors` function to get the relevant state from the surrounding `Culture`.
--- ; When the curly braces (`{_}`) surround a `Culture`, the state us updated with the calculated next state.

--- ; Here, we drive execution forward by exchanging square and curly braces.


    rl [tock] : [ C ] => { C } .
    rl [tick] : { C } => [ C ] .
endm


--- ; Periodic Grid
--- ; -------------


mod PERIODIC-GRID is
   protecting INT .
    extending CELLULAR-AUTOMATA .

    vars N M : Int .

    sort Point .
    ------------
    subsort Point < StateLabel .

    --- Labels are indices in a 5X5 Circular Grid

    op (_,_) : Int Int -> Point .
    op pt    : Int -> Point .
    -------------------------

   ops width height : -> Nat .
    --------------------------
    eq pt(N) = (N rem width, N quo width) .

   ceq (N,M) = (N - width, M)  if N >= width .
   ceq (N,M) = (N, M - height) if M >= height .
   ceq (N,M) = (N + width, M)  if N < 0 .
   ceq (N,M) = (N, M + height) if M < 0 .

    --- States are either `X` or `-`
    --- The neighborhood is the current cell + adjacent cells

   ops up down left right : -> StateKey .
    -------------------------------------
    eq neighbors((N,M))
     = up    [(N , M + 1)]
       left  [(N - 1 , M)]
       down  [(N , M - 1)]
       right [(N + 1 , M)] .
endm



